---
weight: 200
title: "后端模块化开发思考与实践"
---

## 1 前言
&ensp;&ensp;&ensp;&ensp;John Ousterhout 在《软件设计哲学(A Philosophy of Software Design)》中谈到：“计算机科学最基础的问题是问题拆解，即如何把复杂的问题拆解为可以独立解决的问题”。将范围缩小到软件开发领域，这种基础问题的定义仍然适用，软件开发用企业应用解决业务问题，进一步，通过将应用拆分为不同服务系统，服务系统拆分为不同模块的手段降低问题复杂度。相应的，这种将系统分解为独立且相互连接的模块的行为即为模块化。但是真正的模块化，不仅包含在模块拆分层面上，还包含一系列如模块隔离、共享、监控、动态化等更深层次的领域问题。  
&ensp;&ensp;&ensp;&ensp;模块化的优势在于提供了一种管理大型企业应用复杂度的方式，一种降低复杂度的手段。越是复杂的系统（业务复杂、代码量大、外部交互多等），模块化带来的优势越明显。相比规范约束、流程约束或者依赖人员熟练度保证系统的高质量，模块化通过定义内聚性高、边界清晰的功能模块，并借助模块化框架管理模块两种手段构建出自约束能力更强的系统，降低随系统复杂度升高带来的架构腐化程度。通过模块化，研发同学只需关注自身边界与依赖，降低了认知成本与协作成本；重用性强的模块本身就是企业业务资产，通过模块复用，有助于提升研发效率。除此之外，借助模块化框架的模块管理、运行态隔离等能力，可实现更鲁棒的软件系统，这种能力，对于平台型、容器型应用或底层运行框架至关重要。但是，任何一种技术都有它的使用场景与最佳实践，模块化并不能解决所有系统问题，相反，模块化的引入可能会与现有开发习惯、运维体系存在冲突，是否愿意为了更好的隔离性、动态化能力去适应或解决这种冲突，也是权衡是否要引入深层次模块化的重要指标，当然这种权衡指标只能作为业务系统架构升级的参考，如果是底层框架或容器，仅需要考虑模块化能力是否是自身核心能力就可以了。  
&ensp;&ensp;&ensp;&ensp;2019 年以来，基于业务需求与技术演进，到店业务平台框架研发团队发布了插件框架，也与多团队合作研发了应用容器等模块化相关产品。这些产品在业务平台化演进、机器资源利用率提升、Serverless 等场景下得到了广泛的应用。在产品建设过程中，在不同能力的设计实现、不同问题解决的过程中，我们在模块化框架、模块开发域运行域等方向沉淀了一些思考与实践，现在通过本文分享给大家。关键内容上，本文分为两部分，核心原则部分为阐述模块化领域中的关键原则，如关键模式、隔离共享等，实践部分以插件框架的设计与使用为例，进一步说明核心原则在实际场景下的应用。  
  

## 2 模块化核心原则
### 2.1 模块的定义
&ensp;&ensp;&ensp;&ensp;在开始之前，我们首先讨论下模块化领域中模块的定义。  
&ensp;&ensp;&ensp;&ensp;从规范上讲，模块是包含描述元数据的一组资源集合。资源集合物理实体可以是一个 JAR 协议文件，也可以是任何可以被模块化框架解析的实体。以 OSGi 为例，OSGi 将模块定义为 Bundle，Bundle 复用JAR 包中的元数据信息，并在 MANIFEST.MF 中增加 OSGi 必须的扩展信息，如用于声明多模块协作关系的导入导出路径，用来描述 Bundle 唯一标识、授权协议等信息。  
&ensp;&ensp;&ensp;&ensp;从属性上讲，模块是可部署、可管理、可重用、可组合的软件单元。模块是一个可部署的软件单元，如上所述，软件单元可以是独立的 JAR、WAR 等任何形式的物理实体。模块的可管理是指模块的动态化特性，即运行态下，模块可被动态加载、启动、卸载，进而构建可插拔、定制化的软件系统。模块是一个进程内重用单元，模块的重用效果取决于模块的拆分标准，取决于模块是否具有强封装性以及良好的接口定义。模块是无状态的可组合单元，通过多模块组合，实现具备不同能力的系统，以 Eclipse 为例，可通过安装多个不同功能插件，丰富自身集成开发环境不同能力。  
![](/images/DX-20230423@2x.png)  
&ensp;&ensp;&ensp;&ensp;以上面两个概念为标准，包(Package)和服务(Application)都可以抽象为模块进行管理。需要补充说明的是，服务是进程间重用单元，并不严格符合模块化的属性要求，但是从服务物理包角度讲，其同样可被模块化框架抽象为模块管理，所以，将其一并纳入模块定义范畴。  

### 2.2 模块化模式
&ensp;&ensp;&ensp;&ensp;模块化模式与模块化原则，是模块化设计与架构的关键。良好的设计原则可提高模块化系统的可维护性、灵活性与重用性，对系统稳定性提升有帮助。早在 1970 年，Gouthier 和 Pont 在《Designing Systems Programs》一书中清晰描述了模块化设计哲学，提到“模块化将系统划分为独立的、不同的程序模块，每个模块定义自身的输入与输出，并保证与系统中其它模块不混淆。整个系统以模块化的方式进行维护，系统的错误与缺陷可以定位到特定模块，限制错误搜索范围，降低排查成本”。但是，对于系统划分模块使用的标准，此书并无描述。在此之后，D.L.Parnas 在 1972 年的论文《On the criteria to be used in decomposing systems into modules》中提出了模块化标准的重要性，论文中提出了一种 Parnas partitioning 模块化方法，并通过实际例子描述了不同模块化方法带来的不同效果。  
&ensp;&ensp;&ensp;&ensp;模块化最根本的原则应该来源于要解决的业务问题。在此之上，进一步参考基础模式，进而实现系统目标。基础模式为模块化架构提供了切实可行的指导思想，基础模式关注三个方面，首先是模块自身的内聚与重用，其次是多模块间的关系。  
![](/images/DX-20230423@3x.png)  
&ensp;&ensp;&ensp;&ensp;模块内聚与模块重用是模块化最基础的两个模式。模块内聚要求模块自身具有强封装性，模块可以自由修改内部细节而不会对其它模块造成影响，尽可能保持独立。模块内聚也要求模块对外最小化暴露，减小与其它模块的非必要联系。模块重用要求模块职责单一，即使是聚合类型模块，也需要多模块为同一目标服务。模块化通过多模块组合实现模块化系统，模块间关系描述多模块在系统中的组合形式。经典的模块间关系有两种：等级关系与非循环关系。多模块之间严格分层构成了模块间的等级关系，在等级关系之外，可将剩余关系形式统一概括为非循环关系，非循环关系中两模块间同样是单向关系，且需保证模块间关系是一个有向无环图，不存在循环引用。  
&ensp;&ensp;&ensp;&ensp;总的来说，基础模式围绕紧凑与正交两大原则，紧凑原则保证对内有良好抽象，指导如何提高模块的内聚性与模块重用级别。正交性即模块自身的修改与操作不会对其它模块有副作用，帮助模块间建立清晰关系。二者为模块化基础模式提供指导原则。  

### 2.3 模块间隔离
&ensp;&ensp;&ensp;&ensp;隔离是模块化技术最关键的部分之一。  
&ensp;&ensp;&ensp;&ensp;模块间的隔离级别有多种，下图是我们总结的隔离全景，从下到上分为开发期隔离、启动期隔离、运行期隔离，隔离层级递增。其中部分隔离场景如启动期隔离、类隔离、上下文隔离等需要模块化框架支持。  
![](/images/DX-20230423@4x.png)  
&ensp;&ensp;&ensp;&ensp;物理隔离是指模块物理实体的隔离，如仓库隔离、包隔离，这种隔离可借助常用的开发工具实现，如使用 Maven 将模块构建为不同的 JAR 包。  
&ensp;&ensp;&ensp;&ensp;启动期隔离指在多模块系统中单模块加载失败不会影响到其它模块，保证故障不扩散。  
&ensp;&ensp;&ensp;&ensp;运行期隔离包含类隔离、上下文隔离、资源(CPU/Mem/Disk...)隔离。  
&ensp;&ensp;&ensp;&ensp;运行期隔离中的类隔离是指不同模块间仅开放类可见，非开放类无法引用，相互隔离。在 JVM 之上实现的类隔离通常基于多类加载器实现（本文不讨论 JDK 自身的模块化特性，Java9 在 Java 平台引入了模块化特性，可实现 JDK 模块化以及构建模块化系统）。典型可实现类隔离的类加载器架构有两种，如下图所示。图中的 Parent 类加载器泛指 Java 平台提供的如启动类加载器（BootStrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）的集合。图中的 Framework 类加器泛指模块化框架使用的类加载器，在不同的框架实现中，其可能单独存在，也可能复用 Parent 类加载器。其中每个模块有单独的模块类加载器加载，从而实现模块间隔离。  
![](/images/DX-20230423@5x.png)  
&ensp;&ensp;&ensp;&ensp;如上图，一种是以 OSGi 为典型的网状架构，另一种是常见的分层架构。分层架构本身又可根据类加载代理规则分为普通架构与定制架构，下面详细说明各种架构在不同方面优劣。在对比前，为了更好理解表中细节，先就表中所述的代理原则、可见原则、唯一原则进行说明，他们共同构成了类加载器基础三原则：  
+ 代理原则 Delegation。代理原则是指类加载器将类加载请求代理给父类加载器，仅在父类加载器无法加载此类的情况下由自身加载。  
+ 可见性原则 Visibility。可见原则是指父类加载器加载的类对子类加载器可见，但是子类加载器加载的类对父类加载器不可见。  
+ 唯一性原则 Uniqueness。唯一性原则是指一个类仅加载一次（通过代理原则保证），并确保子类加载器不会重新加载父级已经加载的类。  
![](/images/DX-20230423@7x.png)  
&ensp;&ensp;&ensp;&ensp;这种以类加载器为代表的隔离架构，也为模块动态化奠定了基础。  
&ensp;&ensp;&ensp;&ensp;运行期隔离中的上下文隔离是指每个模块有自身的上下文实例，每个上下文都运行在自身环境中，持有自己状态，相互不影响。上下文隔离通常基于类隔离实现，不同的底层类加载器架构会带来不同的上下文隔离实现。如下是一种基于分层架构实现的上下文隔离。其中虚线表示上下层之间可能存在的父子上下文关系。  
![](/images/DX-20230423@8x.png)  
&ensp;&ensp;&ensp;&ensp;运行期隔离中的资源隔离是指多模块系统在运行期各个模块占用的资源隔离，每个模块都使用分配给自身的物理资源。以 Java 为例，多模块系统作为单一进程运行在 JVM 之上，相比多 JVM 实例运行，这种运行形态在一些场景下可能期望能做到资源隔离，如一个模块的资源泄露不会影响到其它模块。资源隔离的一种解决方案是 JVM 层面的虚拟化技术，如 IBM Java8 beta 版发布的多租户技术（Multitenant JVM），但是相关技术还不成熟，暂无大规模应用。  

### 2.4 模块间共享
&ensp;&ensp;&ensp;&ensp;模块间共享资源主要包含类共享、实例共享，除此之外，还可能包含文件等资源共享。以类共享和实例共享为例，可以通过构建类共享空间与实例共享空间的方式实现。  
&ensp;&ensp;&ensp;&ensp;类共享空间构建机制有多种，典型的有两种：  
1. 基于父子类加载器关系的共享。构建类加载器父子关系，并依赖类加载器代理性实现父类加载器加载类共享。  
2. 基于依赖关系的共享。基于依赖关系的共享通常使用模块包导入导出机制实现，被依赖方通过导出声明共享类，依赖方通过导入声明依赖关系。  
&ensp;&ensp;&ensp;&ensp;实例共享通常通过构建共享上下文实现，共享上下文中包含所有已注册的共享实例，模块间通过此上下文实现共享。另一种常见的共享形式是插件形式共享，插件通过扩展点实现实例共享。  

### 2.5 动态化
&ensp;&ensp;&ensp;&ensp;动态化是指在模块化系统中，在运行态下，单模块可被动态加载、启动、卸载而不影响其它模块，进而构建可插拔、定制化的软件系统，大大增加了系统的灵活性。动态化通常基于多类加载器架构实现。动态化意味着每个模块都有自身的运行期上下文，都存在自身的生命周期，模块状态随动态化行为转换，实现生命周期的流转。  
&ensp;&ensp;&ensp;&ensp;事件机制对包含动态化能力的模块化系统非常重要，以模块卸载动作为例，模块卸载后，如果其它模块依赖此模块，需要清理所持有的模块资源，达到真正的卸载目标。下图是一个典型模块动态化模型。  
![](/images/DX-20230423@9x.png)  

### 2.6 模块监控
&ensp;&ensp;&ensp;&ensp;与常规操作系统级别、进程级别的监控不同，模块化开发中，希望能够实现更细粒度，即进程中模块粒度的监控。下面描述一种在实践中总结出的方法，一种模块粒度趋势性监控方法。实现分为三步：  
+ 自动线程标记。在创建、启动模块上下文时，将当前 Context 类加载器设置为模块自身类加载器，基于线程的继承机制，模块线程 Context 类加载器会自动标记为自身类加载器。同时通过同样的模块上下文切换机制，保证在执行过程中创建的线程实现同样的自动标记。  
+ 模块线程定位。通过线程 Context 类加载器标记，可收集到当前时刻模块的所有线程。线程收集可通过遍历获取到根线程组的手段获取到进程中所有线程，之后通过线程 Context 类加载器标记收集到模块维度线程集合。  
+ 指标收集与计算。在获取到模块粒度线程集合后，基于 JMX MxBean 收集并计算各个粒度的指标。以 CPU Time 指标计算为例，计算公式为: $\sum \frac{ThreadCpuTime−PreThreadCpuTime}{ElapsedTime∗1000000F∗nCpus}$  
![](/images/DX-20230423@10x.png)  
&ensp;&ensp;&ensp;&ensp;对于执行过程中存在模块间交互的情况，可能涉及到同一线程，不同时间段在不同模块上下文执行的场景，可利用代理机制，在任务执行切换模块时刻打点，最终统计计算最终的指标值。  
  
## 3 模块化开发实践
&ensp;&ensp;&ensp;&ensp;插件化是模块化的一种特定形式，下面以我们开发的平台化插件框架为例，详细描述在框架研发，业务架构方面对模块化思想以及第二部分所述模块化原则的实践。  
为了能够更好的理解本文档剩余部分内容，下面先了解下插件化开发领域相关名词。  
![](/images/DX-20230423@11x.png)  

### 3.1 业务插件化背景
&ensp;&ensp;&ensp;&ensp;插件框架的背景是业务平台化建设，平台化目标是通过各个方向的平台化建设，降低整体研发成本，提升业务研发效率，促进业务协同创新。插件框架定位于平台与业务分离的插件化架构运行引擎，支持业务平台化演进。  
&ensp;&ensp;&ensp;&ensp;重复建设是平台化所要解决的问题之一。以到店交易场景为例，主业务流程都是类购买、履约、售后。更进一步，购买流程包含的业务节点又都是类生单、支付、关单等，这些是共性。但是不同业务在细节上可能不同，比如价格校验规则、订单扩展信息不同，这是差异点。针对于这种问题，思路也比较明确，就是通用能力沉淀，差异通过扩展体现。在这种思想下，下图左边这种重复建设，或者叫烟囱式架构，就变成了右边分层架构，下层通用能力沉淀为平台，上层不同业务进行差异扩展定制。除此之外，在分层之上还有一层概念增强，叫做分离架构。使用业务与平台分离架构的原因有两个，首先是尽量降低业务与业务之间的耦合，其次是减少平台与业务、业务与业务在开发期、运行期的潜在冲突。  
&ensp;&ensp;&ensp;&ensp;但是，如何支持这种分离架构？更进一步，如何支持这种形态的分离隔离？如何支持在这种分离形态下的扩展？从分离隔离、隔离场景下的扩展和动态管控能力要求上，普通开发模式无法满足要求。从软件模式来讲，这其实是一种插件化架构，需要一种插件化框架来支持。在插件化架构与思想下，业务扩展抽象为业务插件，通过框架嵌入到平台上进行扩展，除此之外，框架支持各角色之间的分离与隔离，以及其它需要的特性。  
![](/images/DX-20230423@12x.png)  
在这样的背景与思路下，考虑开发运维复杂性、三方框架潜在问题与试错成本、稳定性性能问题、与公司技术体系融合等方面，我们自建了插件框架。  

### 3.2 插件框架整体设计
#### 3.2.1 整体架构
&ensp;&ensp;&ensp;&ensp;插件框架架构如下图所示，每个插件包含自身元数据标识，隔离机制保证每个插件运行在自身上下文中，进而实现类、实例层面的隔离。除此之外，插件通过扩展点机制实现对平台的扩展，平台通过资源 API 获取扩展点，框架通过 Proxy Invoker 机制保证每个扩展点都在自身上下文中执行。详细的隔离、扩展等内容，下面详细说明。  
&ensp;&ensp;&ensp;&ensp;除此之外，框架提供打包等开发工具，支撑插件开发。  
![](/images/DX-20230423@13x.png)  

#### 3.2.2 插件规范
&ensp;&ensp;&ensp;&ensp;由于插件形式与普通开发形式在开发期和运行期都存在差异，所以在规范设计上，需要考虑在平台、插件场景以及扩展、隔离能力要求下，如何降低插件形式开发复杂度，以及与公司技术体系融合问题。  
&ensp;&ensp;&ensp;&ensp;规范整体包含两部分，首先是开发域的插件物理结构、插件元属性、扩展声明、隔离体系声明等；其次是运行域的插件生命周期流转、事件监听机制等。在规范制定与落地上，本着规则内置、做增量的原则，尽量降低插件形式的认知成本、开发成本。规则内置，即用户无需关注插件包最终交付形态（FatJar），无需关心底层隔离机制等细节。做增量，即插件包在开发阶段和普通 JAR 包无区别，只要按需配置插件元属性，在标准类上通过注解声明扩展即可完成插件开发。  
![](/images/DX-20230423@14x.png)  
&ensp;&ensp;&ensp;&ensp;其中，上图所示 plugin-descriptor.properties 即为插件元属性声明文件，包含插件 ID、插件描述、启动入口声明、上下文使用声明等选填与必填属性。  

#### 3.2.3 隔离机制
&ensp;&ensp;&ensp;&ensp;采用插件架构的平台化设计中，隔离的必要性体现在两方面。首先是开发期耦合问题，一个平台上运行多个业务，包含几十或者上百个扩展点，需要尽量降低平台与业务、业务与业务的耦合，保证各角色可自助开发。关于耦合问题，可依赖插件身份或者与插件身份存在映射关系的业务身份映射解决，这里不展开说明。隔离必要性第二点体现在非隔离场景下平台与业务以及业务与业务之间潜在的类、实例冲突问题，冲突可能导致运行期异常或错误。  
![](/images/DX-20230423@15x.png)  
&ensp;&ensp;&ensp;&ensp;以类冲突为例，两个插件包有一样的类，在 JVM 体系下只会生效一个，两个插件包的依赖同样会冲突，这种冲突可能导致的结果是运行异常或逻辑错误。但是需要隔离的不只是类，而是业务与平台之间，业务与业务之间在开发期、启动期、运行期各个生命周期上的隔离。  
&ensp;&ensp;&ensp;&ensp;在这样的背景下，默认使用的类加载器架构是本文 2.3 所述分层架构中的普通架构，在这种架构下，可实现插件间类隔离，但不会带来额外的类加载问题，且对类加载速度无影响。除此之外，此架构通过本文 2.4 所述的基于父子类加载器架构的共享策略可以做到和公司技术体系兼容（Appkey），且和普通开发模式相比，虽然引入了插件化架构，但是对 Metaspace 内存占用无影响。Metaspace 理论占用为：$Metaspace_{all}= Metaspace_{platform}+\sum_{i=1}^{n} (Metaspace_{plugin-i}-Metaspace_{common})$，我们也通过下图中测试验证了此内存占用无影响的设想。  
![](/images/DX-20230423@16x.png)  
&ensp;&ensp;&ensp;&ensp;除此之外，使用 2.3 所述上下文隔离实现原则，基于 Spring ApplicationContext 实现了上下文隔离，通过多上下文构建上下文隔离环境。  

#### 3.2.4 扩展机制
&ensp;&ensp;&ensp;&ensp;扩展的目标是实现隔离场景下插件可以扩展平台，也即平台可以使用插件扩展点进行扩展。除此功能特性外，还包含保证扩展点高效执行，保证扩展点在所述插件上下文环境中执行等非功能性考虑。  
![](/images/DX-20230423@17x.png)  
&ensp;&ensp;&ensp;&ensp;针对以上需求，框架通过在编译期、启动期和运行期使用不同策略进行支撑。编译期利用 JSR 269 规范定制处理器对扩展点预收集，避免启动期或运行期扩展点动态扫描对启动或执行耗时影响；启动期平台通过框架加载插件，框架对扩展点进行预实例，并判断插件是否使用 Spring 动态适配扩展点实例获取形式；运行期，平台根据插件身份以及其它参数借助框架获取扩展点，在扩展点执行层面，框架代理扩展点执行操作，保证扩展点运行在插件自身的隔离上下文中。在这样的策略下，用户只需通过注解即可声明扩展点，实现插件对平台的扩展，且扩展的执行性能与本地方法执行效率几乎无差别。  

### 3.3 插件化业务流程
&ensp;&ensp;&ensp;&ensp;在插件化架构下，业务执行流程如 3.2.4 图中运行期部分所示，平台接收到流量，通过流量等执行上下文定位需要执行的插件与扩展点，执行业务流程。  

### 3.4 其它
&ensp;&ensp;&ensp;&ensp;以上简述了插件化框架设计、业务插件化的一些内容，着重描述了在整体设计中对第二部分所述原则的实践。此外，在动态化、监控等部分的设计中，基本复用了第二部分相关原则。当然，框架设计以及业务插件化所涉及的内容不仅如此，这里只描述本文主题模块化相关内容。  

## 4 总结
&ensp;&ensp;&ensp;&ensp;本文整体描述了我们在后端模块化开发过程中的思考与实践。第二部分阐述了模块化开发的核心原则，第三部分通过插件框架与业务插件化两部分内容，描述了对核心原则的实践。希望通过本文，对大家理解模块化有帮助，对模块化框架设计，模块化开发有借鉴意义。由于水平与时间有限，对于文中描述有误之处，还请大家指正。  
&ensp;&ensp;&ensp;&ensp;《技术的本质》一书中描述了广义的技术模块化定义：“新技术都是在现有技术基础上发展起来的，现有技术又来源于先前的技术。将技术进行功能性分组，可以大大简化工程设计，这是技术「模块化」的首要原因”。聚焦到开发过程中的模块化，《Unix 编程艺术》中对其原则、功描述为：“Keeping It Clean, Keeping It Simple”，随着模块化技术发展、实践经验不断积累，我们希望借助模块化的隔离、动态化等更深层面的特性，在"Clean、Simple" 之上，构建更稳定、高效的系统。  

